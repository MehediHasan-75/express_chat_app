# ðŸ“¤ Complete Multer File Upload Guide

## ðŸ“– Table of Contents
- [What is Multer?](#what-is-multer)
- [Installation & Setup](#installation--setup)
- [Basic File Upload](#basic-file-upload)
- [Storage Engines](#storage-engines)
- [File Filtering & Validation](#file-filtering--validation)
- [Multiple File Uploads](#multiple-file-uploads)
- [Advanced Configuration](#advanced-configuration)
- [Error Handling](#error-handling)
- [Complete Express Application](#complete-express-application)
- [Image Processing with Sharp](#image-processing-with-sharp)
- [Cloud Storage (AWS S3, Cloudinary)](#cloud-storage)
- [Best Practices](#best-practices)

---

## ðŸ¤” What is Multer?

**Multer** is a Node.js middleware for handling `multipart/form-data`, primarily used for uploading files.

### Key Features:
- âœ… Handles file uploads in Express applications
- âœ… Supports single and multiple file uploads
- âœ… File type filtering and validation
- âœ… Disk storage and memory storage options
- âœ… File size limits
- âœ… Custom file naming
- âœ… Integration with cloud storage services

### When to Use Multer?
- User profile picture uploads
- Document/PDF uploads
- Image galleries
- CSV/Excel file imports
- Video/audio file uploads
- Any file upload functionality

---

## ðŸ’¾ Installation & Setup

### Install Multer
```bash
npm install multer
```

### Additional Packages (Optional)
```bash
# For image processing
npm install sharp

# For cloud storage
npm install cloudinary multer-storage-cloudinary
npm install aws-sdk multer-s3

# For file type validation
npm install file-type

# For generating unique filenames
npm install uuid
```

### Basic Express Setup
```javascript
const express = require('express');
const multer = require('multer');
const path = require('path');

const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Serve static files (uploaded files)
app.use('/uploads', express.static('uploads'));

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});
```

---

## ðŸ“ Basic File Upload

### 1. Simplest Upload (Default Storage)
```javascript
const multer = require('multer');
const upload = multer({ dest: 'uploads/' });

// Single file upload
app.post('/upload', upload.single('file'), (req, res) => {
  // req.file contains the uploaded file info
  console.log(req.file);
  
  res.json({
    message: 'File uploaded successfully',
    file: req.file
  });
});
```

### 2. Upload with HTML Form
```html
<!DOCTYPE html>
<html>
<head>
  <title>File Upload</title>
</head>
<body>
  <h1>Upload File</h1>
  <form action="/upload" method="POST" enctype="multipart/form-data">
    <input type="file" name="file" required>
    <button type="submit">Upload</button>
  </form>
</body>
</html>
```

### 3. File Object Structure
```javascript
// req.file object contains:
{
  fieldname: 'file',           // Field name from the form
  originalname: 'image.jpg',   // Original filename
  encoding: '7bit',            // Encoding type
  mimetype: 'image/jpeg',      // MIME type
  destination: 'uploads/',     // Destination folder
  filename: 'abc123.jpg',      // Saved filename
  path: 'uploads/abc123.jpg',  // Full path
  size: 12345                  // File size in bytes
}
```

---

## ðŸ—„ï¸ Storage Engines

### 1. Disk Storage (Custom Configuration)

```javascript
const multer = require('multer');
const path = require('path');

// Configure disk storage
const storage = multer.diskStorage({
  // Destination folder
  destination: function (req, file, cb) {
    cb(null, 'uploads/');
  },
  
  // Custom filename
  filename: function (req, file, cb) {
    // Generate unique filename
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({ storage: storage });
```

### 2. Dynamic Destination Folder
```javascript
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    // Different folders for different file types
    if (file.mimetype.startsWith('image/')) {
      cb(null, 'uploads/images/');
    } else if (file.mimetype === 'application/pdf') {
      cb(null, 'uploads/documents/');
    } else {
      cb(null, 'uploads/others/');
    }
  },
  
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});
```

### 3. Custom Filename with UUID
```javascript
const { v4: uuidv4 } = require('uuid');

const storage = multer.diskStorage({
  destination: 'uploads/',
  filename: function (req, file, cb) {
    // Use UUID for unique filenames
    const uniqueName = uuidv4() + path.extname(file.originalname);
    cb(null, uniqueName);
  }
});
```

### 4. Memory Storage (Store in RAM)
```javascript
// Store files in memory as Buffer objects
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

app.post('/upload', upload.single('file'), (req, res) => {
  // File is stored in req.file.buffer
  console.log(req.file.buffer);
  
  // Good for processing files before saving
  // or uploading to cloud storage
});
```

### 5. Organize by Date
```javascript
const fs = require('fs');

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    const date = new Date();
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    
    const dir = `uploads/${year}/${month}/${day}`;
    
    // Create directory if it doesn't exist
    fs.mkdirSync(dir, { recursive: true });
    
    cb(null, dir);
  },
  filename: function (req, file, cb) {
    cb(null, Date.now() + '-' + file.originalname);
  }
});
```

---

## ðŸ” File Filtering & Validation

### 1. Basic File Filter (by MIME type)
```javascript
const fileFilter = (req, file, cb) => {
  // Accept images only
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);  // Accept file
  } else {
    cb(new Error('Only image files are allowed!'), false);  // Reject file
  }
};

const upload = multer({
  storage: storage,
  fileFilter: fileFilter
});
```

### 2. Filter by File Extension
```javascript
const fileFilter = (req, file, cb) => {
  // Allowed extensions
  const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf'];
  const ext = path.extname(file.originalname).toLowerCase();
  
  if (allowedExtensions.includes(ext)) {
    cb(null, true);
  } else {
    cb(new Error(`Only ${allowedExtensions.join(', ')} files are allowed!`), false);
  }
};
```

### 3. Image-Only Filter
```javascript
const imageFilter = (req, file, cb) => {
  const allowedMimes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
  
  if (allowedMimes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Only JPEG, PNG, GIF, and WebP images are allowed!'), false);
  }
};

const upload = multer({
  storage: storage,
  fileFilter: imageFilter,
  limits: { fileSize: 5 * 1024 * 1024 } // 5MB limit
});
```

### 4. Document-Only Filter
```javascript
const documentFilter = (req, file, cb) => {
  const allowedMimes = [
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'application/vnd.ms-excel',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
  ];
  
  if (allowedMimes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Only PDF, Word, and Excel files are allowed!'), false);
  }
};
```

### 5. File Size Limits
```javascript
const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024,  // 10MB in bytes
    files: 5                      // Maximum 5 files
  }
});
```

### 6. Advanced Validation
```javascript
const validateFile = (req, file, cb) => {
  // Check file size
  if (file.size > 5 * 1024 * 1024) {
    return cb(new Error('File too large. Max size is 5MB'));
  }
  
  // Check file extension
  const ext = path.extname(file.originalname).toLowerCase();
  const allowedExts = ['.jpg', '.jpeg', '.png'];
  
  if (!allowedExts.includes(ext)) {
    return cb(new Error('Invalid file type'));
  }
  
  // Check MIME type
  const allowedMimes = ['image/jpeg', 'image/png'];
  
  if (!allowedMimes.includes(file.mimetype)) {
    return cb(new Error('Invalid MIME type'));
  }
  
  cb(null, true);
};
```

---

## ðŸ“¤ Multiple File Uploads

### 1. Single File Upload
```javascript
// upload.single('fieldname')
app.post('/upload/single', upload.single('avatar'), (req, res) => {
  res.json({
    message: 'Single file uploaded',
    file: req.file
  });
});
```

### 2. Multiple Files (Same Field)
```javascript
// upload.array('fieldname', maxCount)
app.post('/upload/multiple', upload.array('photos', 10), (req, res) => {
  // req.files is an array of files
  res.json({
    message: `${req.files.length} files uploaded`,
    files: req.files
  });
});
```

HTML Form:
```html
<form action="/upload/multiple" method="POST" enctype="multipart/form-data">
  <input type="file" name="photos" multiple required>
  <button type="submit">Upload</button>
</form>
```

### 3. Multiple Fields (Different Names)
```javascript
// upload.fields([{name: 'fieldname', maxCount: number}])
app.post('/upload/fields', upload.fields([
  { name: 'avatar', maxCount: 1 },
  { name: 'gallery', maxCount: 5 }
]), (req, res) => {
  // req.files is an object with field names as keys
  res.json({
    message: 'Files uploaded',
    avatar: req.files['avatar'],
    gallery: req.files['gallery']
  });
});
```

HTML Form:
```html
<form action="/upload/fields" method="POST" enctype="multipart/form-data">
  <label>Avatar:</label>
  <input type="file" name="avatar" required>
  
  <label>Gallery:</label>
  <input type="file" name="gallery" multiple>
  
  <button type="submit">Upload</button>
</form>
```

### 4. Any Files (Any Field Names)
```javascript
// upload.any()
app.post('/upload/any', upload.any(), (req, res) => {
  // req.files is an array
  res.json({
    message: 'All files uploaded',
    files: req.files
  });
});
```

### 5. Mixed Upload (Files + Text Data)
```javascript
app.post('/upload/mixed', upload.single('file'), (req, res) => {
  // req.file contains the file
  // req.body contains text fields
  
  res.json({
    message: 'Upload successful',
    file: req.file,
    data: req.body  // { name: 'John', description: '...' }
  });
});
```

HTML Form:
```html
<form action="/upload/mixed" method="POST" enctype="multipart/form-data">
  <input type="text" name="name" placeholder="Name" required>
  <input type="text" name="description" placeholder="Description">
  <input type="file" name="file" required>
  <button type="submit">Upload</button>
</form>
```

---

## âš™ï¸ Advanced Configuration

### 1. Complete Multer Configuration
```javascript
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Ensure upload directory exists
const uploadDir = 'uploads/';
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, file.fieldname + '-' + uniqueSuffix + path.extname(file.originalname));
  }
});

// File filter
const fileFilter = (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif'];
  
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only JPEG, PNG, and GIF are allowed.'), false);
  }
};

// Create multer instance
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 5 * 1024 * 1024,  // 5MB
    files: 10                    // Max 10 files
  }
});

module.exports = upload;
```

### 2. Multer Configuration as Module
```javascript
// config/multer.js
const multer = require('multer');
const path = require('path');

// Storage for images
const imageStorage = multer.diskStorage({
  destination: 'uploads/images/',
  filename: (req, file, cb) => {
    cb(null, Date.now() + path.extname(file.originalname));
  }
});

// Storage for documents
const documentStorage = multer.diskStorage({
  destination: 'uploads/documents/',
  filename: (req, file, cb) => {
    cb(null, Date.now() + path.extname(file.originalname));
  }
});

// Image filter
const imageFilter = (req, file, cb) => {
  if (file.mimetype.startsWith('image/')) {
    cb(null, true);
  } else {
    cb(new Error('Not an image! Please upload an image.'), false);
  }
};

// Document filter
const documentFilter = (req, file, cb) => {
  const allowedTypes = ['application/pdf', 'application/msword'];
  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Only PDF and Word documents are allowed!'), false);
  }
};

// Export configured multer instances
module.exports = {
  uploadImage: multer({
    storage: imageStorage,
    fileFilter: imageFilter,
    limits: { fileSize: 5 * 1024 * 1024 }
  }),
  
  uploadDocument: multer({
    storage: documentStorage,
    fileFilter: documentFilter,
    limits: { fileSize: 10 * 1024 * 1024 }
  })
};
```

### 3. Dynamic File Upload Configuration
```javascript
const createUploader = (options = {}) => {
  const {
    destination = 'uploads/',
    allowedTypes = ['image/jpeg', 'image/png'],
    maxSize = 5 * 1024 * 1024,
    maxFiles = 1
  } = options;
  
  const storage = multer.diskStorage({
    destination: destination,
    filename: (req, file, cb) => {
      cb(null, Date.now() + '-' + file.originalname);
    }
  });
  
  const fileFilter = (req, file, cb) => {
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error(`File type not allowed. Allowed types: ${allowedTypes.join(', ')}`), false);
    }
  };
  
  return multer({
    storage: storage,
    fileFilter: fileFilter,
    limits: {
      fileSize: maxSize,
      files: maxFiles
    }
  });
};

// Usage
const avatarUpload = createUploader({
  destination: 'uploads/avatars/',
  allowedTypes: ['image/jpeg', 'image/png'],
  maxSize: 2 * 1024 * 1024,
  maxFiles: 1
});

const galleryUpload = createUploader({
  destination: 'uploads/gallery/',
  allowedTypes: ['image/jpeg', 'image/png', 'image/gif'],
  maxSize: 5 * 1024 * 1024,
  maxFiles: 10
});
```

---

## âŒ Error Handling

### 1. Basic Error Handling
```javascript
app.post('/upload', (req, res) => {
  upload.single('file')(req, res, (err) => {
    if (err instanceof multer.MulterError) {
      // Multer-specific errors
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({
          error: 'File too large. Maximum size is 5MB.'
        });
      }
      
      if (err.code === 'LIMIT_FILE_COUNT') {
        return res.status(400).json({
          error: 'Too many files. Maximum is 10 files.'
        });
      }
      
      if (err.code === 'LIMIT_UNEXPECTED_FILE') {
        return res.status(400).json({
          error: 'Unexpected field name.'
        });
      }
      
      return res.status(400).json({
        error: err.message
      });
    } else if (err) {
      // Custom errors (from fileFilter)
      return res.status(400).json({
        error: err.message
      });
    }
    
    // Success
    if (!req.file) {
      return res.status(400).json({
        error: 'Please upload a file.'
      });
    }
    
    res.json({
      message: 'File uploaded successfully',
      file: req.file
    });
  });
});
```

### 2. Error Handling Middleware
```javascript
// middleware/uploadErrorHandler.js
const multer = require('multer');

const uploadErrorHandler = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    // Multer errors
    const errorMessages = {
      'LIMIT_FILE_SIZE': 'File is too large',
      'LIMIT_FILE_COUNT': 'Too many files',
      'LIMIT_FIELD_KEY': 'Field name too long',
      'LIMIT_FIELD_VALUE': 'Field value too long',
      'LIMIT_FIELD_COUNT': 'Too many fields',
      'LIMIT_UNEXPECTED_FILE': 'Unexpected field',
      'LIMIT_PART_COUNT': 'Too many parts',
      'MISSING_FIELD_NAME': 'Field name is missing'
    };
    
    return res.status(400).json({
      success: false,
      error: errorMessages[err.code] || err.message
    });
  }
  
  if (err) {
    // Other errors
    return res.status(400).json({
      success: false,
      error: err.message
    });
  }
  
  next();
};

module.exports = uploadErrorHandler;

// Usage
app.post('/upload', upload.single('file'), uploadErrorHandler, (req, res) => {
  res.json({
    success: true,
    file: req.file
  });
});
```

### 3. Comprehensive Error Handler
```javascript
const handleUploadError = (err, req, res, next) => {
  // Log error
  console.error('Upload Error:', err);
  
  // Multer errors
  if (err instanceof multer.MulterError) {
    switch (err.code) {
      case 'LIMIT_FILE_SIZE':
        return res.status(413).json({
          success: false,
          error: 'File size exceeds the limit',
          maxSize: '5MB'
        });
      
      case 'LIMIT_FILE_COUNT':
        return res.status(400).json({
          success: false,
          error: 'Too many files uploaded',
          maxFiles: 10
        });
      
      case 'LIMIT_UNEXPECTED_FILE':
        return res.status(400).json({
          success: false,
          error: 'Unexpected file field',
          expectedField: 'file'
        });
      
      default:
        return res.status(400).json({
          success: false,
          error: err.message
        });
    }
  }
  
  // Custom validation errors
  if (err.message.includes('file type')) {
    return res.status(400).json({
      success: false,
      error: err.message,
      allowedTypes: ['image/jpeg', 'image/png', 'image/gif']
    });
  }
  
  // Generic error
  res.status(500).json({
    success: false,
    error: 'An error occurred during file upload',
    details: err.message
  });
};

// Use in route
app.post('/upload', upload.single('file'), handleUploadError, (req, res) => {
  res.json({ success: true, file: req.file });
});
```

---

## ðŸš€ Complete Express Application

### Project Structure
```
project/
â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ multer.js
â”‚   â””â”€â”€ database.js
â”œâ”€â”€ controllers/
â”‚   â””â”€â”€ uploadController.js
â”œâ”€â”€ middleware/
â”‚   â””â”€â”€ uploadErrorHandler.js
â”œâ”€â”€ models/
â”‚   â””â”€â”€ File.js
â”œâ”€â”€ routes/
â”‚   â””â”€â”€ upload.js
â”œâ”€â”€ uploads/
â”‚   â”œâ”€â”€ images/
â”‚   â”œâ”€â”€ documents/
â”‚   â””â”€â”€ others/
â”œâ”€â”€ public/
â”‚   â””â”€â”€ index.html
â”œâ”€â”€ .env
â”œâ”€â”€ app.js
â””â”€â”€ package.json
```

### 1. Multer Configuration (config/multer.js)
```javascript
const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Ensure directories exist
const dirs = ['uploads/images', 'uploads/documents', 'uploads/others'];
dirs.forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    let uploadPath = 'uploads/others/';
    
    if (file.mimetype.startsWith('image/')) {
      uploadPath = 'uploads/images/';
    } else if (file.mimetype === 'application/pdf') {
      uploadPath = 'uploads/documents/';
    }
    
    cb(null, uploadPath);
  },
  
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    const sanitizedName = file.originalname.replace(/\s+/g, '-');
    cb(null, uniqueSuffix + '-' + sanitizedName);
  }
});

// File filter
const fileFilter = (req, file, cb) => {
  // Allowed MIME types
  const allowedMimes = [
    'image/jpeg',
    'image/png',
    'image/gif',
    'image/webp',
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document'
  ];
  
  if (allowedMimes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only images, PDFs, and Word documents are allowed.'), false);
  }
};

// Multer configuration
const upload = multer({
  storage: storage,
  fileFilter: fileFilter,
  limits: {
    fileSize: 10 * 1024 * 1024,  // 10MB
    files: 10
  }
});

module.exports = upload;
```

### 2. File Model (models/File.js)
```javascript
const mongoose = require('mongoose');

const fileSchema = new mongoose.Schema({
  filename: {
    type: String,
    required: true
  },
  originalname: {
    type: String,
    required: true
  },
  mimetype: {
    type: String,
    required: true
  },
  size: {
    type: Number,
    required: true
  },
  path: {
    type: String,
    required: true
  },
  uploadedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  description: String,
  tags: [String],
  isPublic: {
    type: Boolean,
    default: false
  }
}, {
  timestamps: true
});

// Virtual for file URL
fileSchema.virtual('url').get(function() {
  return `/uploads/${this.path.split('/').slice(-2).join('/')}`;
});

// Instance method to delete file
fileSchema.methods.deleteFile = async function() {
  const fs = require('fs').promises;
  try {
    await fs.unlink(this.path);
    await this.remove();
    return true;
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Delete file
exports.deleteFile = async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    
    if (!file) {
      return res.status(404).json({
        success: false,
        error: 'File not found'
      });
    }
    
    // Delete physical file
    await fs.unlink(file.path);
    
    // Delete from database
    await file.remove();
    
    res.json({
      success: true,
      message: 'File deleted successfully'
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Update file info
exports.updateFile = async (req, res) => {
  try {
    const { description, tags } = req.body;
    
    const file = await File.findByIdAndUpdate(
      req.params.id,
      { 
        description, 
        tags: tags ? tags.split(',') : [] 
      },
      { new: true, runValidators: true }
    );
    
    if (!file) {
      return res.status(404).json({
        success: false,
        error: 'File not found'
      });
    }
    
    res.json({
      success: true,
      message: 'File updated successfully',
      file: file
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};
```

### 4. Routes (routes/upload.js)
```javascript
const express = require('express');
const router = express.Router();
const upload = require('../config/multer');
const uploadErrorHandler = require('../middleware/uploadErrorHandler');
const {
  uploadSingle,
  uploadMultiple,
  getAllFiles,
  getFile,
  downloadFile,
  deleteFile,
  updateFile
} = require('../controllers/uploadController');

// Upload routes
router.post('/single', upload.single('file'), uploadErrorHandler, uploadSingle);
router.post('/multiple', upload.array('files', 10), uploadErrorHandler, uploadMultiple);

// File management routes
router.get('/', getAllFiles);
router.get('/:id', getFile);
router.get('/:id/download', downloadFile);
router.delete('/:id', deleteFile);
router.put('/:id', updateFile);

module.exports = router;
```

### 5. Error Handler Middleware (middleware/uploadErrorHandler.js)
```javascript
const multer = require('multer');

const uploadErrorHandler = (err, req, res, next) => {
  if (err instanceof multer.MulterError) {
    const errorMessages = {
      'LIMIT_FILE_SIZE': 'File size is too large. Maximum size is 10MB.',
      'LIMIT_FILE_COUNT': 'Too many files. Maximum is 10 files.',
      'LIMIT_UNEXPECTED_FILE': 'Unexpected field name in the form.',
      'LIMIT_FIELD_KEY': 'Field name is too long.',
      'LIMIT_FIELD_VALUE': 'Field value is too long.',
      'LIMIT_FIELD_COUNT': 'Too many fields.',
      'LIMIT_PART_COUNT': 'Too many parts in the multipart form.'
    };
    
    return res.status(400).json({
      success: false,
      error: errorMessages[err.code] || err.message,
      code: err.code
    });
  }
  
  if (err) {
    return res.status(400).json({
      success: false,
      error: err.message
    });
  }
  
  next();
};

module.exports = uploadErrorHandler;
```

### 6. Main Application (app.js)
```javascript
const express = require('express');
const mongoose = require('mongoose');
const path = require('path');
const dotenv = require('dotenv');

// Load environment variables
dotenv.config();

// Initialize express
const app = express();

// Middleware
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Serve static files
app.use('/uploads', express.static('uploads'));
app.use(express.static('public'));

// Connect to MongoDB
mongoose.connect(process.env.MONGO_URI || 'mongodb://localhost:27017/fileupload', {
  useNewUrlParser: true,
  useUnifiedTopology: true
})
.then(() => console.log('âœ… MongoDB Connected'))
.catch(err => console.error('âŒ MongoDB Connection Error:', err));

// Routes
app.use('/api/upload', require('./routes/upload'));

// Health check
app.get('/health', (req, res) => {
  res.json({ status: 'OK', message: 'Server is running' });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({
    success: false,
    error: 'Route not found'
  });
});

// Error handler
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    success: false,
    error: 'Internal server error',
    message: err.message
  });
});

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
});
```

### 7. Frontend HTML (public/index.html)
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>File Upload Demo</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 800px;
      margin: 0 auto;
      background: white;
      border-radius: 10px;
      padding: 30px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
    }
    
    h1 {
      color: #333;
      margin-bottom: 30px;
      text-align: center;
    }
    
    .upload-section {
      margin-bottom: 40px;
      padding: 20px;
      border: 2px dashed #ddd;
      border-radius: 8px;
    }
    
    .upload-section h2 {
      color: #555;
      margin-bottom: 15px;
      font-size: 1.2em;
    }
    
    .form-group {
      margin-bottom: 15px;
    }
    
    label {
      display: block;
      margin-bottom: 5px;
      color: #555;
      font-weight: 500;
    }
    
    input[type="file"] {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      cursor: pointer;
    }
    
    input[type="text"],
    textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      font-family: inherit;
    }
    
    textarea {
      resize: vertical;
      min-height: 80px;
    }
    
    button {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      padding: 12px 30px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1em;
      font-weight: 600;
      transition: transform 0.2s;
    }
    
    button:hover {
      transform: translateY(-2px);
    }
    
    button:disabled {
      background: #ccc;
      cursor: not-allowed;
      transform: none;
    }
    
    .progress {
      width: 100%;
      height: 20px;
      background: #f0f0f0;
      border-radius: 10px;
      margin-top: 10px;
      overflow: hidden;
      display: none;
    }
    
    .progress-bar {
      height: 100%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      width: 0%;
      transition: width 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.8em;
      font-weight: 600;
    }
    
    .message {
      margin-top: 15px;
      padding: 12px;
      border-radius: 5px;
      display: none;
    }
    
    .success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    
    .error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    
    .files-list {
      margin-top: 30px;
    }
    
    .file-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      margin-bottom: 10px;
      transition: background 0.2s;
    }
    
    .file-item:hover {
      background: #f9f9f9;
    }
    
    .file-info {
      flex: 1;
    }
    
    .file-name {
      font-weight: 600;
      color: #333;
      margin-bottom: 5px;
    }
    
    .file-meta {
      font-size: 0.9em;
      color: #777;
    }
    
    .file-actions button {
      margin-left: 5px;
      padding: 8px 15px;
      font-size: 0.9em;
    }
    
    .delete-btn {
      background: #dc3545;
    }
    
    .download-btn {
      background: #28a745;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸ“¤ File Upload Demo</h1>
    
    <!-- Single File Upload -->
    <div class="upload-section">
      <h2>Upload Single File</h2>
      <form id="singleForm">
        <div class="form-group">
          <label for="singleFile">Choose File:</label>
          <input type="file" id="singleFile" name="file" required>
        </div>
        
        <div class="form-group">
          <label for="description">Description:</label>
          <textarea id="description" name="description" placeholder="Optional description"></textarea>
        </div>
        
        <div class="form-group">
          <label for="tags">Tags (comma-separated):</label>
          <input type="text" id="tags" name="tags" placeholder="e.g., work, important">
        </div>
        
        <button type="submit" id="singleBtn">Upload File</button>
        <div class="progress" id="singleProgress">
          <div class="progress-bar" id="singleProgressBar">0%</div>
        </div>
        <div class="message" id="singleMessage"></div>
      </form>
    </div>
    
    <!-- Multiple Files Upload -->
    <div class="upload-section">
      <h2>Upload Multiple Files</h2>
      <form id="multipleForm">
        <div class="form-group">
          <label for="multipleFiles">Choose Files:</label>
          <input type="file" id="multipleFiles" name="files" multiple required>
        </div>
        
        <button type="submit" id="multipleBtn">Upload Files</button>
        <div class="progress" id="multipleProgress">
          <div class="progress-bar" id="multipleProgressBar">0%</div>
        </div>
        <div class="message" id="multipleMessage"></div>
      </form>
    </div>
    
    <!-- Files List -->
    <div class="files-list">
      <h2>Uploaded Files</h2>
      <div id="filesList"></div>
    </div>
  </div>

  <script>
    // Single file upload
    document.getElementById('singleForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const formData = new FormData(e.target);
      const btn = document.getElementById('singleBtn');
      const progress = document.getElementById('singleProgress');
      const progressBar = document.getElementById('singleProgressBar');
      const message = document.getElementById('singleMessage');
      
      btn.disabled = true;
      progress.style.display = 'block';
      message.style.display = 'none';
      
      try {
        const xhr = new XMLHttpRequest();
        
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percentComplete = Math.round((e.loaded / e.total) * 100);
            progressBar.style.width = percentComplete + '%';
            progressBar.textContent = percentComplete + '%';
          }
        });
        
        xhr.addEventListener('load', () => {
          if (xhr.status === 201) {
            const response = JSON.parse(xhr.responseText);
            message.textContent = response.message;
            message.className = 'message success';
            message.style.display = 'block';
            e.target.reset();
            loadFiles();
          } else {
            const response = JSON.parse(xhr.responseText);
            message.textContent = response.error;
            message.className = 'message error';
            message.style.display = 'block';
          }
          btn.disabled = false;
          setTimeout(() => {
            progress.style.display = 'none';
            progressBar.style.width = '0%';
          }, 2000);
        });
        
        xhr.open('POST', '/api/upload/single');
        xhr.send(formData);
      } catch (error) {
        message.textContent = 'Upload failed: ' + error.message;
        message.className = 'message error';
        message.style.display = 'block';
        btn.disabled = false;
      }
    });
    
    // Multiple files upload
    document.getElementById('multipleForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      
      const formData = new FormData(e.target);
      const btn = document.getElementById('multipleBtn');
      const progress = document.getElementById('multipleProgress');
      const progressBar = document.getElementById('multipleProgressBar');
      const message = document.getElementById('multipleMessage');
      
      btn.disabled = true;
      progress.style.display = 'block';
      message.style.display = 'none';
      
      try {
        const xhr = new XMLHttpRequest();
        
        xhr.upload.addEventListener('progress', (e) => {
          if (e.lengthComputable) {
            const percentComplete = Math.round((e.loaded / e.total) * 100);
            progressBar.style.width = percentComplete + '%';
            progressBar.textContent = percentComplete + '%';
          }
        });
        
        xhr.addEventListener('load', () => {
          if (xhr.status === 201) {
            const response = JSON.parse(xhr.responseText);
            message.textContent = response.message;
            message.className = 'message success';
            message.style.display = 'block';
            e.target.reset();
            loadFiles();
          } else {
            const response = JSON.parse(xhr.responseText);
            message.textContent = response.error;
            message.className = 'message error';
            message.style.display = 'block';
          }
          btn.disabled = false;
          setTimeout(() => {
            progress.style.display = 'none';
            progressBar.style.width = '0%';
          }, 2000);
        });
        
        xhr.open('POST', '/api/upload/multiple');
        xhr.send(formData);
      } catch (error) {
        message.textContent = 'Upload failed: ' + error.message;
        message.className = 'message error';
        message.style.display = 'block';
        btn.disabled = false;
      }
    });
    
    // Load files
    async function loadFiles() {
      try {
        const response = await fetch('/api/upload/');
        const data = await response.json();
        
        const filesList = document.getElementById('filesList');
        
        if (data.files.length === 0) {
          filesList.innerHTML = '<p style="color: #999;">No files uploaded yet.</p>';
          return;
        }
        
        filesList.innerHTML = data.files.map(file => `
          <div class="file-item">
            <div class="file-info">
              <div class="file-name">${file.originalname}</div>
              <div class="file-meta">
                ${formatFileSize(file.size)} â€¢ ${new Date(file.createdAt).toLocaleString()}
              </div>
            </div>
            <div class="file-actions">
              <button class="download-btn" onclick="downloadFile('${file._id}', '${file.originalname}')">
                Download
              </button>
              <button class="delete-btn" onclick="deleteFile('${file._id}')">
                Delete
              </button>
            </div>
          </div>
        `).join('');
      } catch (error) {
        console.error('Error loading files:', error);
      }
    }
    
    // Download file
    function downloadFile(id, filename) {
      window.location.href = `/api/upload/${id}/download`;
    }
    
    // Delete file
    async function deleteFile(id) {
      if (!confirm('Are you sure you want to delete this file?')) return;
      
      try {
        const response = await fetch(`/api/upload/${id}`, {
          method: 'DELETE'
        });
        
        const data = await response.json();
        
        if (data.success) {
          alert(data.message);
          loadFiles();
        } else {
          alert('Error: ' + data.error);
        }
      } catch (error) {
        alert('Error deleting file: ' + error.message);
      }
    }
    
    // Format file size
    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
    }
    
    // Load files on page load
    loadFiles();
  </script>
</body>
</html>
```

---

## ðŸ–¼ï¸ Image Processing with Sharp

### Installation
```bash
npm install sharp
```

### 1. Basic Image Resizing
```javascript
const sharp = require('sharp');
const multer = require('multer');
const path = require('path');

// Use memory storage for processing
const storage = multer.memoryStorage();
const upload = multer({ storage: storage });

app.post('/upload/image', upload.single('image'), async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No file uploaded' });
    }
    
    const filename = Date.now() + '-' + req.file.originalname;
    const filepath = path.join('uploads/images', filename);
    
    // Resize and save image
    await sharp(req.file.buffer)
      .resize(800, 600, {
        fit: 'inside',
        withoutEnlargement: true
      })
      .jpeg({ quality: 90 })
      .toFile(filepath);
    
    res.json({
      message: 'Image uploaded and resized',
      filename: filename
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 2. Multiple Image Sizes (Thumbnails)
```javascript
app.post('/upload/image-variants', upload.single('image'), async (req, res) => {
  try {
    const filename = Date.now() + '-' + path.parse(req.file.originalname).name;
    
    // Create multiple sizes
    const sizes = [
      { name: 'thumbnail', width: 150, height: 150 },
      { name: 'small', width: 400, height: 300 },
      { name: 'medium', width: 800, height: 600 },
      { name: 'large', width: 1200, height: 900 }
    ];
    
    const savedFiles = await Promise.all(
      sizes.map(async (size) => {
        const outputPath = `uploads/images/${filename}-${size.name}.jpg`;
        
        await sharp(req.file.buffer)
          .resize(size.width, size.height, {
            fit: 'cover',
            position: 'center'
          })
          .jpeg({ quality: 85 })
          .toFile(outputPath);
        
        return {
          size: size.name,
          path: outputPath
        };
      })
    );
    
    res.json({
      message: 'Image variants created',
      files: savedFiles
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 3. Image Optimization
```javascript
const optimizeImage = async (buffer, outputPath) => {
  await sharp(buffer)
    .resize(1200, 1200, {
      fit: 'inside',
      withoutEnlargement: true
    })
    .jpeg({
      quality: 80,
      progressive: true,
      mozjpeg: true
    })
    .toFile(outputPath);
};

app.post('/upload/optimized', upload.single('image'), async (req, res) => {
  try {
    const filename = Date.now() + '.jpg';
    const filepath = path.join('uploads/images', filename);
    
    await optimizeImage(req.file.buffer, filepath);
    
    const stats = await fs.promises.stat(filepath);
    
    res.json({
      message: 'Image optimized and uploaded',
      originalSize: req.file.size,
      optimizedSize: stats.size,
      savings: ((1 - stats.size / req.file.size) * 100).toFixed(2) + '%',
      filename: filename
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 4. Watermark Images
```javascript
app.post('/upload/watermark', upload.single('image'), async (req, res) => {
  try {
    const filename = Date.now() + '.jpg';
    const filepath = path.join('uploads/images', filename);
    
    // Create watermark
    const watermark = await sharp({
      text: {
        text: 'Â© Your Company',
        font: 'Arial',
        fontSize: 40,
        rgba: true
      }
    })
    .png()
    .toBuffer();
    
    // Add watermark to image
    await sharp(req.file.buffer)
      .composite([{
        input: watermark,
        gravity: 'southeast'
      }])
      .toFile(filepath);
    
    res.json({
      message: 'Image uploaded with watermark',
      filename: filename
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

---

## â˜ï¸ Cloud Storage

### 1. Cloudinary Integration

#### Installation
```bash
npm install cloudinary multer-storage-cloudinary
```

#### Configuration
```javascript
const cloudinary = require('cloudinary').v2;
const { CloudinaryStorage } = require('multer-storage-cloudinary');

// Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

// Create Cloudinary storage
const storage = new CloudinaryStorage({
  cloudinary: cloudinary,
  params: {
    folder: 'uploads',
    allowed_formats: ['jpg', 'jpeg', 'png', 'gif'],
    transformation: [{ width: 1000, height: 1000, crop: 'limit' }]
  }
});

const upload = multer({ storage: storage });

// Upload to Cloudinary
app.post('/upload/cloudinary', upload.single('image'), (req, res) => {
  res.json({
    message: 'Image uploaded to Cloudinary',
    url: req.file.path,
    publicId: req.file.filename
  });
});

// Delete from Cloudinary
app.delete('/upload/cloudinary/:publicId', async (req, res) => {
  try {
    const result = await cloudinary.uploader.destroy(req.params.publicId);
    res.json({
      message: 'Image deleted from Cloudinary',
      result: result
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### 2. AWS S3 Integration

#### Installation
```bash
npm install aws-sdk multer-s3
```

#### Configuration
```javascript
const AWS = require('aws-sdk');
const multer = require('multer');
const multerS3 = require('multer-s3');

// Configure AWS
AWS.config.update({
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  region: process.env.AWS_REGION
});

const s3 = new AWS.S3();

// Create S3 storage
const upload = multer({
  storage: multerS3({
    s3: s3,
    bucket: process.env.AWS_BUCKET_NAME,
    acl: 'public-read',
    metadata: function (req, file, cb) {
      cb(null, { fieldName: file.fieldname });
    },
    key: function (req, file, cb) {
      cb(null, Date.now().toString() + '-' + file.originalname);
    }
  })
});

// Upload to S3
app.post('/upload/s3', upload.single('file'), (req, res) => {
  res.json({
    message: 'File uploaded to S3',
    url: req.file.location,
    key: req.file.key
  });
});

// Delete from S3
app.delete('/upload/s3/:key', async (req, res) => {
  try {
    await s3.deleteObject({
      Bucket: process.env.AWS_BUCKET_NAME,
      Key: req.params.key
    }).promise();
    
    res.json({ message: 'File deleted from S3' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

---

## âœ… Best Practices

### 1. **Always Validate Files**
```javascript
// Validate file type, size, and content
const fileFilter = (req, file, cb) => {
  // Check MIME type
  const allowedMimes = ['image/jpeg', 'image/png'];
  if (!allowedMimes.includes(file.mimetype)) {
    return cb(new Error('Invalid file type'), false);
  }
  
  cb(null, true);
};
```

### 2. **Sanitize Filenames**
```javascript
const sanitizeFilename = (filename) => {
  return filename
    .toLowerCase()
    .replace(/\s+/g, '-')          // Replace spaces with hyphens
    .replace(/[^a-z0-9.-]/g, '')   // Remove special characters
    .replace(/--+/g, '-');          // Replace multiple hyphens
};
```

### 3. **Use Unique Filenames**
```javascript
// Always generate unique filenames to avoid conflicts
const uniqueFilename = Date.now() + '-' + Math.random().toString(36).substring(7);
```

### 4. **Set File Size Limits**
```javascript
const upload = multer({
  limits: {
    fileSize: 5 * 1024 * 1024,  // 5MB limit
    files: 10                    // Max 10 files
  }
});
```

### 5. **Store Files Outside Public Directory**
```javascript
// Don't store uploads in public/static folders
// Use a separate 'uploads' directory
const storage = multer.diskStorage({
  destination: 'uploads/' // Outside public directory
});
```

### 6. **Validate on Both Client and Server**
```html
<!-- Client-side validation -->
<input type="file" accept="image/*" required>
```

```javascript
// Server-side validation (always required)
const fileFilter = (req, file, cb) => {
  // Validation logic
};
```

### 7. **Handle Errors Properly**
```javascript
app.post('/upload', (req, res) => {
  upload.single('file')(req, res, (err) => {
    if (err) {
      return res.status(400).json({ error: err.message });
    }
    // Success handling
  });
});
```

### 8. **Clean Up Failed Uploads**
```javascript
app.post('/upload', upload.single('file'), async (req, res) => {
  try {
    // Process file
    // ...
  } catch (error) {
    // Delete uploaded file if processing fails
    if (req.file) {
      await fs.promises.unlink(req.file.path);
    }
    res.status(500).json({ error: error.message });
  }
});
```

### 9. **Use Environment Variables**
```javascript
// .env file
UPLOAD_DIR=uploads/
MAX_FILE_SIZE=5242880
CLOUDINARY_URL=cloudinary://...

// Usage
const storage = multer.diskStorage({
  destination: process.env.UPLOAD_DIR
});
```

### 10. **Implement Rate Limiting**
```bash
npm install express-rate-limit
```

```javascript
const rateLimit = require('express-rate-limit');

const uploadLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 10, // Limit each IP to 10 uploads per windowMs
  message: 'Too many uploads,) {
    console.error('Error deleting file:', error);
    return false;
  }
};

module.exports = mongoose.model('File', fileSchema);
```

### 3. Upload Controller (controllers/uploadController.js)
```javascript
const File = require('../models/File');
const fs = require('fs').promises;
const path = require('path');

// Upload single file
exports.uploadSingle = async (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: 'Please upload a file'
      });
    }
    
    // Save file info to database
    const fileData = new File({
      filename: req.file.filename,
      originalname: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      path: req.file.path,
      description: req.body.description,
      tags: req.body.tags ? req.body.tags.split(',') : []
    });
    
    await fileData.save();
    
    res.status(201).json({
      success: true,
      message: 'File uploaded successfully',
      file: {
        id: fileData._id,
        filename: fileData.filename,
        originalname: fileData.originalname,
        size: fileData.size,
        url: `/uploads/${req.file.path.split('/').slice(-2).join('/')}`
      }
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Upload multiple files
exports.uploadMultiple = async (req, res) => {
  try {
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({
        success: false,
        error: 'Please upload at least one file'
      });
    }
    
    // Save all files to database
    const savedFiles = await Promise.all(
      req.files.map(file => {
        return File.create({
          filename: file.filename,
          originalname: file.originalname,
          mimetype: file.mimetype,
          size: file.size,
          path: file.path
        });
      })
    );
    
    res.status(201).json({
      success: true,
      message: `${req.files.length} files uploaded successfully`,
      files: savedFiles.map(file => ({
        id: file._id,
        filename: file.filename,
        originalname: file.originalname,
        size: file.size
      }))
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get all files
exports.getAllFiles = async (req, res) => {
  try {
    const files = await File.find().sort({ createdAt: -1 });
    
    res.json({
      success: true,
      count: files.length,
      files: files
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Get single file
exports.getFile = async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    
    if (!file) {
      return res.status(404).json({
        success: false,
        error: 'File not found'
      });
    }
    
    res.json({
      success: true,
      file: file
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
};

// Download file
exports.downloadFile = async (req, res) => {
  try {
    const file = await File.findById(req.params.id);
    
    if (!file) {
      return res.status(404).json({
        success: false,
        error: 'File not found'
      });
    }
    
    res.download(file.path, file.originalname);
  } catch (error