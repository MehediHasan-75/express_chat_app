# Step-by-Step Project Setup

## **0. Create Project Folder**

```bash
mkdir express_chat_app
cd express_chat_app
npm init     // initialize the folder as a Node.js project
```

(Optional)
Create a folder:

```
.vscode   â†’ for formatting settings
```

---

## **1. Create the main entry file**

```
create app.js
```

---

Here is the **same section**, restructured **beautifully** with **short explanations** for each package â€” clean, minimal, and to the point.

---

## **2. Install Required Packages**

```bash
npm i express dotenv ejs mongoose multer cookie-parser express-validator jsonwebtoken bcrypt http-errors
```

### **Package Purpose (Short & Simple)**

| Package               | Purpose (Short Description)                      |
| --------------------- | ------------------------------------------------ |
| **express**           | Web framework for creating server and APIs       |
| **dotenv**            | Load environment variables from `.env` file      |
| **ejs**               | Template engine for rendering dynamic HTML views |
| **mongoose**          | Connect and interact with MongoDB database       |
| **multer**            | Handle file uploads (images, documents, etc.)    |
| **cookie-parser**     | Parse cookies from incoming requests             |
| **express-validator** | Validate and sanitize user input                 |
| **jsonwebtoken**      | Create and verify JWT tokens (authentication)    |
| **bcrypt**            | Hash user passwords securely                     |
| **http-errors**       | Create and manage HTTP error objects easily      |
---

## **3. Create and Load `.env`**

Create a `.env` file:

```
APP_NAME=express_chat_app
```

Use it inside `app.js`:

```js
const dotenv = require("dotenv");
dotenv.config(); 
// this will enable access using process.env.VARIABLE_NAME through the app
```

---

## **4. Database Connection Setup**

Add in `.env`:

```
MONGO_CONNECTION=mongodb://127.0.0.1/chat
```

In `app.js`:

```js
const mongoose = require("mongoose");

mongoose.connect(process.env.MONGO_CONNECTION)
  .then(() => console.log("database connection successful!"))
  .catch((err) => console.log(err));
```

---

## **5. Request Parsers**

```js
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
```

---

## **6. Set the View Engine**

> First create a folder named `views`.
> Express will search for all EJS views inside this folder by default.

```js
app.set("view engine", "ejs");
```

---

## **7. Set Static Folder**

```js
const path = require("path");
app.use(express.static(path.join(__dirname, "public")));
```

---

## **8. Parse Cookies**

Add in `.env`:

```
COOKIE_SECRET=/InUJLSB_iJF,@3Ktw+^?FHSdFf!FS|RC|@%y@e_40DQ6=sl>V+ ybhwQmoXbS
```

Use it in `app.js`:

```js
const cookieParser = require("cookie-parser");
app.use(cookieParser(process.env.COOKIE_SECRET));
```

---

## **9. Routing Setup**

(Will be added later)

---

## **10. Error Handler Setup**

(Will be added later)

---

## **11. App Listening**

```js
app.listen(process.env.PORT, () => {
    console.log(`app listening to port ${process.env.PORT}`);
});
```

---

# **package.json Scripts Setup**

Add the following inside `"scripts"`:

```json
"scripts": {
  "dev": "NODE_ENV=development nodemon app.js",
  "prod": "NODE_ENV=production nodemon app.js"
}
```

---

# **Error Handling Setup (Create Separate Folder)**

> Since error handlers in Node.js are middleware,
> we should implement them in a different folder for modularity.

Create this folder structure:

```
middlewares/common/errorHandler.js
```

---

# **Error Handler Section**


## **1. 404 Not Found Handler**


* 404 Not Found Handler
* When the application reaches a 404 not found area, this function will be called.
* After calling this, we pass the error to the default error handling middleware.


```js
const createError = require("http-errors");

function notFoundHandler(req, res, next) { 
    console.log("ERROR HANDLER HIT:", err?.status, err?.message);
    next(createError(404, "Your requested content was not found!")); 
    // Anything passed inside next() is considered an error except inside routes
}
```
---

## **2. Default Error Handler â€” Explanation + Code**

* Default error handler receives 4 parameters, including `err`.

```js
// default error handler
function errorHandler(err, req, res, next) { 
    res.render("error", {  // this object is accessible from error.ejs
        title: "Error Page",
    }); 
    // If we want to show a response as HTML,
    // we should call res.render() with the path of the EJS/HTML template.
}
//export both handlers
module.exports = {
    notFoundHandler,
    errorHandler,
};
```
---

## **3. error.ejs Template**

Create:

```
views/error.ejs
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title><%= title %></title>
</head>
<body>
    This is error Page
</body>
</html>
```

---

## **5. Add Error Handlers Inside `app.js`**

After completing `error.ejs` and `errorHandler.js`, add:

```js
const { notFoundHandler, errorHandler } = require("./middlewares/common/errorHandler");

app.use(notFoundHandler);
app.use(errorHandler);
```

Here is a **short, clear, and structured explanation** of **how the error handlers are called from `app.js`**, written exactly in your style.

---

# â­ **How Error Handlers Are Called from `app.js` (Brief Explanation)**

Inside `app.js`, after all routes are loaded, we add:

```js
app.use(notFoundHandler);
app.use(errorHandler);
```
# **Flow Diagram**

```
Request â†’ Routes â†’ Match?
          â”‚
          â”œâ”€â”€ Yes â†’ Normal Response
          â”‚
          â””â”€â”€ No â†’ (Express moves to the next middleware) notFoundHandler 
                    â†’ next(error) 
                    â†’ (Express automatically invokes any middleware defined with 4 parameters) errorHandler 
                    â†’ error.ejs
```
Here is your section **reformatted, cleaner, clearer, and updated** with your new insight about `app.listen` not checking the error.

---

# ðŸŸ¥ **PROBLEM FACED: Access to 127.0.0.1 Was Denied (HTTP ERROR 403)**

## **Cause**

On macOS Ventura/Sonoma, **port 5000 is already used by system services (ControlCenter)**.
So when your app ran:

```js
app.listen(process.env.PORT, () => {
    console.log(`app listening to port ${process.env.PORT}`);
});
```

Express **printed the message** but **never actually bound to port 5000**, because it doesn't show port errors by default.

After adding an error callback:

```js
app.listen(process.env.PORT, (err) => {
    if (err) console.log(err);
    console.log(`app listening to port ${process.env.PORT}`);
});
```

You finally saw the real error:

```
Error: listen EADDRINUSE: address already in use :::5000
```

Checking the port:

```bash
sudo lsof -i :5000
```

Showed:

```
ControlCenter
```

Meaning all requests to `127.0.0.1:5000` were hitting **macOS ControlCenter**, which returned the **403 Access Denied** page.

---

## **Fix**

Use a different port, for example:

```
PORT=5001
```

(Or 3000, 4000, 8000 â€” anything except 5000.)