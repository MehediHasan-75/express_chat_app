# First, we need a clear execution flow of `app.js`

# **PHASE 1: SERVER STARTS (File loads top to bottom)**

### **1. Load external modules**

```js
const express = require("express");
const dotenv = require("dotenv");
const mongoose = require("mongoose");
const path = require("path");
const cookieParser = require("cookie-parser");
```
‚úî `Node.js` loads these modules from your SSD/HDD into RAM (your program‚Äôs memory space).
---

### **2. Load internal modules**

```js
const {notFoundHandler, errorHandler} = require("./middlewares/common/errorHandler");
const loginRouter = require("./router/loginRouter");
const inboxRouter = require("./router/inboxRouter");
const usersRouter = require("./router/usersRouter");
```
‚úî Your custom middlewares & routers are loaded in the same process.
---

### **3. Express app created**

```js
const app = express();
```

‚úî Creates the Express application `object`.

This also sets up an **empty internal middleware stack**.

---

### **4. Load .env file**

```js
dotenv.config();
```

‚úî Enables usage of `process.env.*`.

---

### **5. Connect to MongoDB**

```js
mongoose.connect(process.env.MONGO_CONNECTION)
```

‚úî Database connection happens
‚úî If success ‚Üí prints success
‚úî If fail ‚Üí prints error

---

### **6. Add request parsers**

```js
app.use(express.json());
app.use(express.urlencoded({extended: true}));
```

‚úî These are added to the middleware stack.

---

### **7. Configure EJS view engine**

```js
app.set("view engine", "ejs");
```

---

### **8. Set static folder**

```js
app.use(express.static(path.join(__dirname, "public")));
```

‚úî Another middleware added
‚úî Serves images, css, js files

---

### **9. Parse cookies**

```js
app.use(cookieParser(process.env.COOKIE_SECRET));
```
‚úî Adds cookie parser middleware

### **10. Add 404 handler**

```js
app.use(notFoundHandler)
```
‚úî Adds your **normal middleware** (3 params)

---

### **11. Add final error handler**

```js
app.use(errorHandler)
```

‚úî Adds **error middleware** (4 params)

---

### **12. Start server**

```js
app.listen(...)
```

‚úî Server starts
‚úî Now the request cycle begins

---

---

# üî• **PHASE 2: WHEN A REQUEST COMES (THE REAL FLOW)**

Let‚Äôs say the request is:

```
GET /something
```

Express will now run the middleware stack EXACTLY in order they were added.

---

# üìú **Actual middleware stack (in order)**

1. express.json()
2. express.urlencoded()
3. express.static()
4. cookieParser()
5. notFoundHandler      ‚Üê normal middleware
6. errorHandler         ‚Üê error middleware
---

# üîÅ **REQUEST FLOW STEP BY STEP**

---

## **1. express.json() runs**

It parses JSON if present
Then calls:

```js
next();
```

---

## **2. express.urlencoded() runs**

It parses form data
Then:

```js
next();
```

---

## **3. express.static() runs**

It checks if `/something` exists in `public/`

* If file found ‚Üí return file
* If not ‚Üí `next()`

---

## **4. cookieParser() runs**

Parses cookies, then:

```js
next();
```

---

## **5. notFoundHandler runs**

Because **no previous route matched** (you didn't mount routes):

```js
notFoundHandler(req, res, next)
```

Inside it, you probably do:

```js
next(error);
```

This is the CRITICAL point.

`next(error)` tells Express:

> ‚ÄúSwitch to error mode. Skip all normal middlewares.‚Äù

---

## **6. Express looks for the NEXT middleware with 4 params**

It finds:

```js
app.use(errorHandler)
```

This is your final error handler:

```js
function errorHandler(err, req, res, next) {
    ...
}
```

Express calls it:

```js
errorHandler(error, req, res, next);
```

---

## **7. errorHandler sends response**

Usually:

* status code
* error page
* or JSON

Request ends.