# How to build a **Real-Time Chat Application** using **Socket.IO**, **MongoDB**, **EJS**, and **Express**

---

# 1ï¸âƒ£ Setup Socket.IO in Main App (`app.js`)

Initialize Socket.IO and make it globally available for real-time communication.

```js
// external imports
const express = require("express");
const http = require("http");
const dotenv = require("dotenv");
const mongoose = require("mongoose");
const path = require("path");
const cookieParser = require("cookie-parser");
const moment = require("moment");

// internal imports
const loginRouter = require("./router/loginRouter");
const usersRouter = require("./router/usersRouter");
const inboxRouter = require("./router/inboxRouter");
const {
  notFoundHandler,
  errorHandler,
} = require("./middlewares/common/errorHandler");

const app = express();
const server = http.createServer(app);

dotenv.config();

// Socket.IO initialization
const io = require("socket.io")(server);
global.io = io;

// Set moment as app locals for EJS templates
app.locals.moment = moment;

// database connection
mongoose
  .connect(process.env.MONGO_CONNECTION_STRING, {
    useNewUrlParser: true,
    useUnifiedTopology: true,
  })
  .then(() => {
    console.log("Database connected!");
  })
  .catch((err) => console.log(err));

// View engine setup
app.set("view engine", "ejs");
app.set("views", path.join(__dirname, "views"));

// middleware
app.use(express.static(path.join(__dirname, "public")));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(cookieParser(process.env.COOKIE_SECRET));

// router setup
app.use("/", loginRouter);
app.use("/users", usersRouter);
app.use("/inbox", inboxRouter);

// 404 handler
app.use(notFoundHandler);

// common error handler
app.use(errorHandler);

server.listen(process.env.PORT, () => {
  console.log(`app listening to port ${process.env.PORT}`);
});
```

---

# 2ï¸âƒ£ Create Conversation Model (`models/Conversation.js`)

Stores conversation metadata between two users.

```js
const mongoose = require("mongoose");

const conversationSchema = mongoose.Schema(
  {
    creator: {
      id: mongoose.Types.ObjectId,
      name: String,
      avatar: String,
    },

    participant: {
      id: mongoose.Types.ObjectId,
      name: String,
      avatar: String,
    },

    last_updated: {
      type: Date,
      default: Date.now,
    },
  },
  {
    timestamps: true,
  }
);

const Conversation = mongoose.model("Conversation", conversationSchema);

module.exports = Conversation;
```

---

# 3ï¸âƒ£ Create Message Model (`models/Message.js`)

Stores individual messages with attachments and timestamps.

```js
const mongoose = require("mongoose");

const messageSchema = mongoose.Schema(
  {
    text: {
      type: String,
    },

    attachment: [
      {
        type: String,
      },
    ],

    sender: {
      id: mongoose.Types.ObjectId,
      name: String,
      avatar: String,
    },

    receiver: {
      id: mongoose.Types.ObjectId,
      name: String,
      avatar: String,
    },

    date_time: {
      type: Date,
      default: Date.now,
    },

    conversation_id: {
      type: mongoose.Types.ObjectId,
      required: true,
    },
  },
  {
    timestamps: true,
  }
);

const Message = mongoose.model("Message", messageSchema);

module.exports = Message;
```

---

# 4ï¸âƒ£ Create Attachment Upload Middleware (`middleware/inbox/attachmentUpload.js`)

Handles multiple file uploads for chat attachments.

```js
const uploader = require("../../utilities/multipleUploader");

function attachmentUpload(req, res, next) {
  const upload = uploader(
    "attachments",
    ["image/jpeg", "image/jpg", "image/png"],
    1000000, // 1MB max per file
    2,       // max 2 files
    "Only .jpg, jpeg or .png format allowed!"
  );

  // call the middleware function
  upload.any()(req, res, (err) => {
    if (err) {
      res.status(500).json({
        errors: {
          avatar: {
            msg: err.message,
          },
        },
      });
    } else {
      next();
    }
  });
}

module.exports = attachmentUpload;
```

---

# 5ï¸âƒ£ Create Multiple Uploader Utility (`utilities/multipleUploader.js`)

Reusable utility for handling multiple file uploads.

```js
// external imports
const multer = require("multer");
const path = require("path");
const createError = require("http-errors");

function uploader(
  subfolder_path,
  allowed_file_types,
  max_file_size,
  max_number_of_files,
  error_msg
) {
  // File upload folder
  const UPLOADS_FOLDER = `${__dirname}/../public/uploads/${subfolder_path}/`;

  // define the storage
  const storage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, UPLOADS_FOLDER);
    },

    filename: (req, file, cb) => {
      const fileExt = path.extname(file.originalname);
      const fileName =
        file.originalname
          .replace(fileExt, "")
          .toLowerCase()
          .split(" ")
          .join("-") +
        "-" +
        Date.now();

      cb(null, fileName + fileExt);
    },
  });

  // prepare the final multer upload object
  const upload = multer({
    storage: storage,
    limits: {
      fileSize: max_file_size,
    },

    fileFilter: (req, file, cb) => {
      if (req.files.length > max_number_of_files) {
        cb(
          createError(
            `Maximum ${max_number_of_files} files are allowed to upload!`
          )
        );
      } else {
        if (allowed_file_types.includes(file.mimetype)) {
          cb(null, true);
        } else {
          cb(createError(error_msg));
        }
      }
    },
  });

  return upload;
}

module.exports = uploader;
```

---

# 6ï¸âƒ£ Create String Escape Utility (`utilities/escape.js`)

Safely escapes special regex characters for search queries.

```js
const escape = function (str) {
  return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
};

module.exports = escape;
```

---

# 7ï¸âƒ£ Update Inbox Controller (`controller/inboxController.js`)

Handles conversations, message fetching, searching, and real-time messaging.

```js
// external imports
const createError = require("http-errors");

// internal imports
const User = require("../models/People");
const Conversation = require("../models/Conversation");
const Message = require("../models/Message");
const escape = require("../utilities/escape");

// get inbox page with all conversations
async function getInbox(req, res, next) {
  try {
    const conversations = await Conversation.find({
      $or: [
        { "creator.id": req.user.userid },
        { "participant.id": req.user.userid },
      ],
    });

    res.locals.data = conversations;
    res.render("inbox");
  } catch (err) {
    next(err);
  }
}

// search user by name, mobile, or email
async function searchUser(req, res, next) {
  const user = req.body.user;
  const searchQuery = user.replace("+88", "");

  const name_search_regex = new RegExp(escape(searchQuery), "i");
  const mobile_search_regex = new RegExp("^" + escape("+88" + searchQuery));
  const email_search_regex = new RegExp("^" + escape(searchQuery) + "$", "i");

  try {
    if (searchQuery !== "") {
      const users = await User.find(
        {
          $or: [
            {
              name: name_search_regex,
            },
            {
              mobile: mobile_search_regex,
            },
            {
              email: email_search_regex,
            },
          ],
        },
        "name avatar"
      );

      res.json(users);
    } else {
      throw createError("You must provide some text to search!");
    }
  } catch (err) {
    res.status(500).json({
      errors: {
        common: {
          msg: err.message,
        },
      },
    });
  }
}

// create a new conversation between two users
async function addConversation(req, res, next) {
  try {
    const newConversation = new Conversation({
      creator: {
        id: req.user.userid,
        name: req.user.username,
        avatar: req.user.avatar || null,
      },
      participant: {
        name: req.body.participant,
        id: req.body.id,
        avatar: req.body.avatar || null,
      },
    });

    const result = await newConversation.save();

    res.status(200).json({
      message: "Conversation was added successfully!",
    });
  } catch (err) {
    res.status(500).json({
      errors: {
        common: {
          msg: err.message,
        },
      },
    });
  }
}

// get all messages for a specific conversation
async function getMessages(req, res, next) {
  try {
    const messages = await Message.find({
      conversation_id: req.params.conversation_id,
    }).sort("-createdAt");

    const { participant } = await Conversation.findById(
      req.params.conversation_id
    );

    res.status(200).json({
      data: {
        messages: messages,
        participant,
      },
      user: req.user.userid,
      conversation_id: req.params.conversation_id,
    });
  } catch (err) {
    res.status(500).json({
      errors: {
        common: {
          msg: "Unknown error occurred!",
        },
      },
    });
  }
}

// send a new message with optional attachments
async function sendMessage(req, res, next) {
  if (req.body.message || (req.files && req.files.length > 0)) {
    try {
      // save message text/attachment in database
      let attachments = null;

      if (req.files && req.files.length > 0) {
        attachments = [];

        req.files.forEach((file) => {
          attachments.push(file.filename);
        });
      }

      const newMessage = new Message({
        text: req.body.message,
        attachment: attachments,
        sender: {
          id: req.user.userid,
          name: req.user.username,
          avatar: req.user.avatar || null,
        },
        receiver: {
          id: req.body.receiverId,
          name: req.body.receiverName,
          avatar: req.body.avatar || null,
        },
        conversation_id: req.body.conversationId,
      });

      const result = await newMessage.save();

      // emit socket event for real-time message delivery
      global.io.emit("new_message", {
        message: {
          conversation_id: req.body.conversationId,
          sender: {
            id: req.user.userid,
            name: req.user.username,
            avatar: req.user.avatar || null,
          },
          message: req.body.message,
          attachment: attachments,
          date_time: result.date_time,
        },
      });

      res.status(200).json({
        message: "Successful!",
        data: result,
      });
    } catch (err) {
      res.status(500).json({
        errors: {
          common: {
            msg: err.message,
          },
        },
      });
    }
  } else {
    res.status(500).json({
      errors: {
        common: "Message text or attachment is required!",
      },
    });
  }
}

module.exports = {
  getInbox,
  searchUser,
  addConversation,
  getMessages,
  sendMessage,
};
```

---

# 8ï¸âƒ£ Setup Inbox Routes (`router/inboxRouter.js`)

API endpoints for chat functionality.

```js
const express = require("express");

// internal imports
const {
  getInbox,
  searchUser,
  addConversation,
  getMessages,
  sendMessage,
} = require("../controller/inboxController");

const decorateHtmlResponse = require("../middlewares/common/decorateHtmlResponse");
const { checkLogin } = require("../middlewares/common/checkLogin");
const attachmentUpload = require("../middlewares/inbox/attachmentUpload");

const router = express.Router();

// inbox page
router.get("/", decorateHtmlResponse("Inbox"), checkLogin, getInbox);

// search user for conversation
router.post("/search", checkLogin, searchUser);

// add conversation
router.post("/conversation", checkLogin, addConversation);

// get messages of a conversation
router.get("/messages/:conversation_id", checkLogin, getMessages);

// send message
router.post("/message", checkLogin, attachmentUpload, sendMessage);

module.exports = router;
```

---

# 9ï¸âƒ£ Create Inbox View (`views/inbox.ejs`)

Main chat UI with Socket.IO integration for real-time messaging.

```ejs
<%- include('./partials/header.ejs'); %>

<div id="chat-container">
  <div id="chat-sidebar">
    <div id="search-bar">
      <input type="text" placeholder="Search" />
    </div>
    
    <div id="conversation-list">
      <% data.forEach(function(conversation) { %>
        <!-- Show participant if current user is creator -->
        <% if(conversation.creator.id == loggedInUser.userid) { %>
          <div class="conversation" onclick="getMessages('<%= conversation._id %>', '<%= conversation.participant.name %>')">
            <% if (conversation.participant.avatar) { %>
              <img src="./uploads/avatars/<%= conversation.participant.avatar %>" alt="<%= conversation.participant.name %>" />
            <% } else { %>
              <img src="./images/nophoto.png" />
            <% } %>
            <div class="title-text"><%= conversation.participant.name %></div>
            <div class="conversation-date"><%= moment(conversation.last_updated).fromNow() %></div>
          </div>
        <% } else { %>
          <div class="conversation" onclick="getMessages('<%= conversation._id %>', '<%= conversation.creator.name %>')">
            <% if (conversation.creator.avatar) { %>
              <img src="./uploads/avatars/<%= conversation.creator.avatar %>" alt="<%= conversation.creator.name %>" />
            <% } else { %>
              <img src="./images/nophoto.png" />
            <% } %>
            <div class="title-text"><%= conversation.creator.name %></div>
            <div class="conversation-date"><%= moment(conversation.last_updated).fromNow() %></div>
          </div>
        <% } %>
      <% }); %>

      <!-- Show placeholder if no conversations -->
      <% if(data && data.length === 0) { %>
        <div class="nothing"><img src="./images/no-conversation.svg"></div>
      <% } %>
    </div>

    <!-- Create new conversation button -->
    <div class="new-message-container" onclick="openModal()">
      <a href="#">+</a>
    </div>
  </div>

  <!-- Chat area -->
  <div id="chat-content">
    <div id="chat-title">
      <span id="conversation-partner"></span>
      <img src="./images/trash.png" alt="Delete Conversation" />
    </div>

    <!-- Messages display area -->
    <div id="chat-message-list">
      <div class="nothing">select a conversation</div>
    </div>

    <!-- Message input form -->
    <form id="chat-form" method="post" enctype="multipart/form-data">
      <label for="attachment"><img src="./images/attachment.png" alt="Add Attachment" /></label>
      <input type="file" multiple name="attachment" class="hide" id="attachment" />
      <input type="text" name="message" placeholder="Type a message" autocomplete="off" />
    </form>
  </div>
</div>

<!-- Add conversation modal -->
<%- include('./partials/add-conversation-modal.ejs'); %>

<!-- Socket.IO real-time messaging -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/3.1.3/socket.io.min.js"></script>

<script>
  const form = document.querySelector('#chat-form');
  const messageContainer = document.querySelector('#chat-message-list');
  const chatTitleContainer = document.querySelector('#conversation-partner');
  const loggedinUserId = '<%= loggedInUser.userid %>';
  const loggedinUserName = '<%= loggedInUser.username %>';
  let participant = null;
  let current_conversation_id;

  // Socket initialization
  const socket = io('<%= process.env.APP_URL %>');

  // Handle incoming messages in real-time
  socket.on("new_message", data => {
    if(data.message.conversation_id == current_conversation_id) {
      const messageClass = data.message.sender.id === loggedinUserId ? 'you-message' : 'other-message';
      const senderAvatar = data.message.sender.avatar ? 
        `<img src="./uploads/avatars/${data.message.sender.avatar}" alt="${data.message.sender.name}" />` : 
        `<img src="./images/nophoto.png" alt="${data.message.sender.name}" />`;

      let attachments = '<div class="attachments">';
      if(data.message.attachment && data.message.attachment.length > 0) {
        data.message.attachment.forEach(attachment => {
          attachments += `<img src="./uploads/attachments/${attachment}" /> `;
        });
      }
      attachments += '</div>';

      let messageHTML;
      if(data.message.sender.id == loggedinUserId) {
        messageHTML = `<div class="message-row ${messageClass}"><div class="message-content">
          <div class="message-text">${data.message.message}</div>
          ${attachments}
          <div class="message-time">${moment(data.message.date_time).fromNow()}</div>
        </div></div>`;
      } else {
        messageHTML = `<div class="message-row ${messageClass}"><div class="message-content">
          ${senderAvatar}
          <div class="message-text">${data.message.message}</div>
          ${attachments}
          <div class="message-time">${moment(data.message.date_time).fromNow()}</div>
        </div></div>`;
      }

      document.querySelector('#chat-message-list > .message-row:first-child').insertAdjacentHTML('beforeBegin', messageHTML);
    }
  });

  // Get messages for a conversation
  async function getMessages(conversation_id, current_conversation_name){
    let response = await fetch(`/inbox/messages/${conversation_id}`);
    const result = await response.json();

    if(!result.errors && result.data) {
      form.style.visibility = 'visible';
      const {data, user, conversation_id} = result;
      participant = data.participant;
      current_conversation_id = conversation_id;

      if(data.messages) {
        let allMessages = '';

        if(data.messages.length > 0) {
          data.messages.forEach((message) => {
            let senderAvatar = message.sender.avatar ? 
              `./uploads/avatars/${message.sender.avatar}` : 
              './images/nophoto.png';
            const messageClass = message.sender.id === loggedinUserId ? 'you-message' : 'other-message';
            const showAvatar = message.sender.id === loggedinUserId ? '' : 
              `<img src="${senderAvatar}" alt="${message.sender.name}" />`;

            let attachments = '<div class="attachments">';
            if(message.attachment && message.attachment.length > 0) {
              message.attachment.forEach(attachment => {
                attachments += `<img src="./uploads/attachments/${attachment}" /> `;
              });
            }
            attachments += '</div>';

            let messageHTML = `<div class="message-row ${messageClass}"><div class="message-content">
              ${showAvatar}
              <div class="message-text">${message.text}</div>
              ${attachments}
              <div class="message-time">${moment(message.date_time).fromNow()}</div>
            </div></div>`;

            allMessages += messageHTML;
            messageContainer.innerHTML = allMessages;
          });
        } else {
          messageContainer.innerHTML = '<div class="message-row"></div>';
        }

        chatTitleContainer.textContent = current_conversation_name;
      }
    }
  }

  // Send message
  form.onsubmit = async function (event) {
    event.preventDefault();

    const formData = new FormData(form);
    formData.append('receiverId', participant.id);
    formData.append('receiverName', participant.name);
    formData.append('avatar', participant.avatar || '');
    formData.append('conversationId', current_conversation_id);

    let response = await fetch("/inbox/message", {
      method: "POST",
      body: formData,
    });

    let result = await response.json();
    if (!result.errors) {
      form.reset();
    }
  }
</script>
```

---

# ğŸ”Ÿ Create Add Conversation Modal (`views/partials/add-conversation-modal.ejs`)

Modal interface for searching users and creating conversations.

```ejs
<div class="modal-wrapper" id="add-conversation-modal">
  <div class="modal">
    <a onclick="closeModal()" class="modal-close">+</a>
    <div class="modal-title">
      <h2>Create New Conversation</h2>
    </div>
    <div class="modal-body">
      <form id="add-conversation-form">
        <input
          type="text"
          placeholder="search user by name or email or mobile"
          name="user"
          id="user"
          autocomplete="off"
        />
        <p class="error"></p>
        <div class="search_users"></div>
        <input type="submit" value="Submit" class="hide" />
      </form>
    </div>
  </div>
</div>

<script>
  const modal = document.querySelector("#add-conversation-modal");
  let typingTimer;
  const doneTypingInterval = 500;
  const input = document.querySelector("input#user");
  const conversation_list = document.querySelector("#conversation-list");
  let users_placeholder = document.querySelector(".search_users");

  function closeModal() {
    modal.style.display = "none";
    users_placeholder.style.display = "none";
    input.value = "";
  }

  function openModal() {
    modal.style.display = "block";
  }

  // Search users after typing stops
  input.addEventListener("keyup", function () {
    clearTimeout(typingTimer);
    users_placeholder.style.display = "none";

    if (input.value) {
      typingTimer = setTimeout(searchUsers, doneTypingInterval);
    }
  });

  input.addEventListener("keydown", function () {
    clearTimeout(typingTimer);
  });

  // Send search request
  async function searchUsers() {
    let response = await fetch("/inbox/search", {
      method: "POST",
      body: JSON.stringify({ user: input.value }),
      headers: { "Content-type": "application/json; charset=UTF-8" },
    });

    let result = await response.json();

    if (result.errors) {
      const errorplaceholder = document.querySelector("p.error");
      errorplaceholder.textContent = result.errors.common.msg;
      errorplaceholder.style.display = "block";
    } else {
      if (result.length > 0) {
        let generatedHtml = "<ul>";
        result.forEach((user) => {
          const avatar = user.avatar ? "./uploads/avatars/" + user.avatar : "./images/nophoto.png";
          generatedHtml += `<li onclick="createConversation('${user._id}', '${user.name}', '${user.avatar}')">
            <div class="user">
              <div class="avatar"><img src="${avatar}" /></div>
              <div class="username">${user.name}</div>
            </div>
          </li>`;
        });
        generatedHtml += "</ul>";
        users_placeholder.innerHTML = generatedHtml;
        users_placeholder.style.display = "block";
      }
    }
  }

  // Create conversation
  async function createConversation(participant_id, name, avatar) {
    try {
      const response = await fetch("/inbox/conversation", {
        method: "POST",
        body: JSON.stringify({
          participant: name,
          id: participant_id,
          avatar: avatar != "undefined" ? avatar : null,
        }),
        headers: { "Content-type": "application/json; charset=UTF-8" },
      });

      const result = response.json();

      if (!result.errors) {
        users_placeholder.style.display = "none";
        input.value = name;
        setTimeout(() => {
          location.reload();
        }, 1000);
      }
    } catch (err) {
      console.error(err);
    }
  }
</script>
```

---

# ğŸ“Š How The Real-Time Chat Flow Works

## 1. User Logs In â†’ Inbox Page (`GET /`)

- Server fetches all conversations where user is creator or participant
- EJS template renders conversation list with participant info
- Socket.IO client connects to server

## 2. User Clicks on Conversation

- Frontend calls `getMessages(conversation_id)`
- Server returns all messages for that conversation
- Messages display in chat area with "you-message" or "other-message" class

## 3. User Types and Sends Message

- Frontend intercepts form submit
- FormData prepared with message, receiver info, attachments
- POST to `/inbox/message` with `attachmentUpload` middleware
- Server saves message to MongoDB

## 4. Real-Time Delivery via Socket.IO

- Server **emits** `new_message` event via `global.io.emit()`
- All connected clients receive the event
- If event conversation ID matches current open conversation â†’ display message
- Message appears instantly without page reload

## 5. Search and Create Conversation

- User types in modal search field (debounced with 500ms timer)
- Frontend fetches `/inbox/search` with query
- Results filtered by name, mobile, email regex
- Click on user â†’ POST to `/inbox/conversation`
- New conversation saved â†’ page reloads

---

# ğŸ›  Key Utilities Explained

| Utility | Purpose |
|---------|---------|
| **multipleUploader** | Handles multiple file uploads with size/type validation |
| **escape** | Escapes regex special chars in search queries for safety |
| **Socket.IO global** | Makes `io` available throughout app for emitting events |
| **Moment.js** | Formats timestamps (e.g., "2 minutes ago") |

---

# ğŸ“¦ Required Dependencies

```json
{
  "dependencies": {
    "express": "^4.17.1",
    "mongoose": "^5.12.11",
    "socket.io": "^4.1.2",
    "multer": "^1.4.2",
    "jsonwebtoken": "^8.5.1",
    "cookie-parser": "^1.4.5",
    "dotenv": "^8.2.0",
    "ejs": "^3.1.6",
    "moment": "^2.29.1"
  }
}
```

---

# ğŸ” Real-Time Security Features

- **JWT Protected Routes** - Only logged-in users can access chat
- **User Verification** - Messages linked to authenticated user ID
- **Conversation Validation** - Users can only see conversations they're part of
- **Input Escaping** - Search queries escaped to prevent regex injection
- **File Validation** - Only specific MIME types allowed for uploads

---

# ğŸ“ Complete File Structure

```
project/
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ Conversation.js         # Conversation schema
â”‚   â”œâ”€â”€ Message.js              # Message schema
â”‚   â””â”€â”€ People.js               # User schema (from previous lesson)
â”œâ”€â”€ controller/
â”‚   â”œâ”€â”€ inboxController.js      # Chat logic
â”‚   â””â”€â”€ loginController.js      # Login logic
â”œâ”€â”€ middleware/
â”‚   â”œâ”€â”€ inbox/
â”‚   â”‚   â””â”€â”€ attachmentUpload.js # File upload middleware
â”‚   â””â”€â”€ common/
â”‚       â”œâ”€â”€ checkLogin.js       # JWT verification
â”‚       â””â”€â”€ decorateHtmlResponse.js
â”œâ”€â”€ utilities/
â”‚   â”œâ”€â”€ multipleUploader.js     # Multiple file upload utility
â”‚   â””â”€â”€ escape.js               # Regex safe string escape
â”œâ”€â”€ router/
â”‚   â””â”€â”€ inboxRouter.js          # Chat API routes
â”œâ”€â”€ views/
â”‚   â”œâ”€â”€ inbox.ejs               # Main chat UI
â”‚   â””â”€â”€ partials/
â”‚       â”œâ”€â”€ header.ejs          # Navigation
â”‚       â””â”€â”€ add-conversation-modal.ejs # Search & create
â”œâ”€â”€ app.js                      # Express + Socket.IO setup
â””â”€â”€ .env                        # Environment config
```

---

# ğŸš€ Quick Implementation Checklist

1. âœ… Install Socket.IO: `npm install socket.io`
2. âœ… Create HTTP server wrapper in `app.js`
3. âœ… Initialize Socket.IO with `io = require("socket.io")(server)`
4. âœ… Make `global.io` for emitting from controllers
5. âœ… Create Conversation & Message models
6. âœ… Create inbox controller with search and messaging logic
7. âœ… Setup inbox routes with attachment middleware
8. âœ… Create inbox.ejs with Socket.IO client code
9. âœ… Create add-conversation modal for search
10. âœ… Test real-time messaging between users